2017-07-15 14:26:57.955 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 456 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:26:57.957 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:27:28.123 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 31.346 seconds (JVM running for 33.271)
2017-07-15 14:29:14.862 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 11000 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:29:14.880 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:29:40.250 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 26.983 seconds (JVM running for 28.334)
2017-07-15 14:29:40.422 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 0
2017-07-15 14:29:40.423 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - []
2017-07-15 14:34:53.851 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 7304 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:34:53.853 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:35:23.398 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 31.358 seconds (JVM running for 32.829)
2017-07-15 14:35:23.606 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 0
2017-07-15 14:35:23.606 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - []
2017-07-15 14:35:50.112 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 1144 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:35:50.114 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:36:18.809 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 30.216 seconds (JVM running for 31.859)
2017-07-15 14:36:19.095 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 0
2017-07-15 14:36:19.096 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - []
2017-07-15 14:37:58.202 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 6068 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:37:58.204 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:38:26.611 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 29.902 seconds (JVM running for 31.36)
2017-07-15 14:38:26.842 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 0
2017-07-15 14:38:26.843 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - []
2017-07-15 14:39:49.709 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 1188 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:39:49.711 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:40:14.059 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 26.199 seconds (JVM running for 27.543)
2017-07-15 14:40:14.279 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 2
2017-07-15 14:40:14.280 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - [ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。), ArticleDO(id=1, author=陆奇, title=成为优秀工程师的五个方法, body=首先要相信技术，我刚才已经讲了，整个我们工业界，特别是像百度这样的公司，对技术坚定的、不动摇的信念特别重要。

我也分享一下，盖茨提到微软公司的宗旨就是：写软件代表的是世界的将来。

为什么？未来任何一个工业都会变成软件工业。盖茨是对的，因为任何工业任何行业自动化的程度会越来越高，最后你所处理的就是信息和知识。

但现在软件的做法又往前提了一次，因为在人工智能时代，不光是写代码，你必须懂算法，懂硬件，懂数据，整个人工智能的开发过程有一个很大程度的提高，但是，技术，特别是我们这个工业所代表的技术一定是将来任何工业的前沿。

所以 我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。)]
2017-07-15 14:41:05.757 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 10140 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:41:05.764 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:41:31.195 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 26.966 seconds (JVM running for 28.265)
2017-07-15 14:41:31.465 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 2
2017-07-15 14:41:31.465 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - [ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。), ArticleDO(id=1, author=陆奇, title=成为优秀工程师的五个方法, body=首先要相信技术，我刚才已经讲了，整个我们工业界，特别是像百度这样的公司，对技术坚定的、不动摇的信念特别重要。

我也分享一下，盖茨提到微软公司的宗旨就是：写软件代表的是世界的将来。

为什么？未来任何一个工业都会变成软件工业。盖茨是对的，因为任何工业任何行业自动化的程度会越来越高，最后你所处理的就是信息和知识。

但现在软件的做法又往前提了一次，因为在人工智能时代，不光是写代码，你必须懂算法，懂硬件，懂数据，整个人工智能的开发过程有一个很大程度的提高，但是，技术，特别是我们这个工业所代表的技术一定是将来任何工业的前沿。

所以 我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。)]
2017-07-15 14:43:10.958 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 2060 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:43:10.960 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:43:35.572 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 26.637 seconds (JVM running for 28.034)
2017-07-15 14:43:35.794 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 2
2017-07-15 14:43:35.795 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - [ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。), ArticleDO(id=1, author=陆奇, title=成为优秀工程师的五个方法, body=首先要相信技术，我刚才已经讲了，整个我们工业界，特别是像百度这样的公司，对技术坚定的、不动摇的信念特别重要。

我也分享一下，盖茨提到微软公司的宗旨就是：写软件代表的是世界的将来。

为什么？未来任何一个工业都会变成软件工业。盖茨是对的，因为任何工业任何行业自动化的程度会越来越高，最后你所处理的就是信息和知识。

但现在软件的做法又往前提了一次，因为在人工智能时代，不光是写代码，你必须懂算法，懂硬件，懂数据，整个人工智能的开发过程有一个很大程度的提高，但是，技术，特别是我们这个工业所代表的技术一定是将来任何工业的前沿。

所以 我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。)]
2017-07-15 14:50:37.632 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 8260 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:50:37.637 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:51:07.379 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 31.88 seconds (JVM running for 33.386)
2017-07-15 14:51:07.572 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 0
2017-07-15 14:51:07.573 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - []
2017-07-15 14:54:29.288 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 11240 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:54:29.291 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:54:57.916 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 30.652 seconds (JVM running for 32.443)
2017-07-15 14:54:58.229 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 0
2017-07-15 14:54:58.230 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - []
2017-07-15 14:58:35.503 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 48] - Starting ArticleCustomRepositoryTest on LAPTOP-0E5JL9PN with PID 6652 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 14:58:35.505 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 14:59:02.014 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [StartupInfoLogger.java : 57] - Started ArticleCustomRepositoryTest in 28.081 seconds (JVM running for 29.407)
2017-07-15 14:59:02.233 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 22] - 0
2017-07-15 14:59:02.234 INFO  [main] c.s.s.d.a.ArticleCustomRepositoryTest [ArticleCustomRepositoryTest.java : 23] - []
2017-07-15 16:37:48.088 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 2000 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:37:48.091 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:38:34.156 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 48.492 seconds (JVM running for 50.656)
2017-07-15 16:38:34.472 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 1, 5]
2017-07-15 16:38:34.605 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 2 of 1 containing UNKNOWN instances
2017-07-15 16:40:08.693 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 10224 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:40:08.696 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:40:52.395 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 46.095 seconds (JVM running for 48.039)
2017-07-15 16:40:52.748 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 1, 5]
2017-07-15 16:40:52.929 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 2 of 1 containing UNKNOWN instances
2017-07-15 16:40:52.929 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 68] - 1
2017-07-15 16:40:52.930 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 69] - Page 2 of 1 containing UNKNOWN instances
2017-07-15 16:42:38.960 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 9116 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:42:38.963 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:43:23.090 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 46.209 seconds (JVM running for 48.176)
2017-07-15 16:43:23.651 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 1, 5]
2017-07-15 16:43:23.821 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 2 of 1 containing UNKNOWN instances
2017-07-15 16:43:23.823 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 69] - 1
2017-07-15 16:44:38.419 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 11048 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:44:38.431 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:45:21.668 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 45.09 seconds (JVM running for 46.956)
2017-07-15 16:45:22.124 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 1, 5]
2017-07-15 16:45:22.359 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 2 of 1 containing UNKNOWN instances
2017-07-15 16:45:22.360 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 69] - 1
2017-07-15 16:46:49.385 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 7812 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:46:49.389 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:47:33.550 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 46.803 seconds (JVM running for 48.554)
2017-07-15 16:47:33.810 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 1, 5]
2017-07-15 16:47:33.920 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 2 of 1 containing UNKNOWN instances
2017-07-15 16:47:33.921 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:0
2017-07-15 16:49:51.417 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 8912 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:49:51.419 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:50:40.630 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 51.715 seconds (JVM running for 53.78)
2017-07-15 16:50:40.801 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 1, 5]
2017-07-15 16:50:40.913 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 2 of 1 containing UNKNOWN instances
2017-07-15 16:50:40.914 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:0
2017-07-15 16:53:32.345 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 8708 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:53:32.347 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:54:07.521 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 37.136 seconds (JVM running for 38.885)
2017-07-15 16:54:07.715 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 16:54:07.936 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 16:54:07.938 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 16:54:07.938 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 16:55:23.890 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 10868 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:55:23.894 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:55:59.887 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 38.065 seconds (JVM running for 40.0)
2017-07-15 16:56:00.118 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 16:56:00.361 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 16:56:00.362 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 16:56:00.363 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 16:58:17.582 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 7228 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 16:58:17.592 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 16:58:49.996 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 34.449 seconds (JVM running for 36.004)
2017-07-15 16:58:50.174 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 16:58:50.347 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 16:58:50.349 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 16:58:50.349 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 17:05:55.908 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 6696 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 17:05:55.911 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 17:06:29.784 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 35.683 seconds (JVM running for 37.325)
2017-07-15 17:06:29.987 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 17:06:30.219 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 17:06:30.220 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 17:06:30.227 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 17:13:02.024 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 3424 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 17:13:02.027 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 17:13:35.937 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 35.787 seconds (JVM running for 37.635)
2017-07-15 17:13:36.083 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 17:13:36.276 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 17:13:36.277 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 17:13:36.277 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 17:51:30.061 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 6160 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 17:51:30.072 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 17:52:10.271 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 41.924 seconds (JVM running for 43.513)
2017-07-15 17:52:10.698 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 17:52:11.006 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 17:52:11.007 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 17:52:11.008 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 17:52:44.899 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 5028 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 17:52:44.902 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 17:53:23.571 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 40.531 seconds (JVM running for 42.148)
2017-07-15 17:53:23.731 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 17:53:23.767 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 73] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 17:53:23.877 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 17:53:23.878 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 17:53:23.879 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:05:30.334 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 8220 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:05:30.337 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:06:02.499 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 10372 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:06:02.503 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:06:35.768 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 35.653 seconds (JVM running for 37.406)
2017-07-15 18:06:35.936 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:06:36.095 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 32] - Error happened in method: [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ]
2017-07-15 18:06:36.096 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 33] - Parameters: [Hybrid, 0, 5]
2017-07-15 18:06:36.100 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 34] - Exception StackTrace: {}
java.lang.NullPointerException: null
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$1.mapResults(ArticleServiceImpl.java:93)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.queryForPage(ElasticsearchTemplate.java:277)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(ArticleServiceImpl.java:82)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$FastClassBySpringCGLIB$$7ca1735a.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$EnhancerBySpringCGLIB$$5a4bab49.findByBodyContainingWithHighlight(<generated>)
	at cn.sinjinsong.skeleton.service.article.ArticleServiceTest.findByBodyContainingWithHighlight(ArticleServiceTest.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
2017-07-15 18:08:29.115 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 10576 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:08:29.118 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:09:06.037 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 39.023 seconds (JVM running for 40.67)
2017-07-15 18:09:06.260 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:09:06.379 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 92] - null
2017-07-15 18:09:06.381 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 32] - Error happened in method: [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ]
2017-07-15 18:09:06.382 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 33] - Parameters: [Hybrid, 0, 5]
2017-07-15 18:09:06.386 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 34] - Exception StackTrace: {}
java.lang.NullPointerException: null
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$1.mapResults(ArticleServiceImpl.java:93)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.queryForPage(ElasticsearchTemplate.java:277)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(ArticleServiceImpl.java:82)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$FastClassBySpringCGLIB$$7ca1735a.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$EnhancerBySpringCGLIB$$850d3b63.findByBodyContainingWithHighlight(<generated>)
	at cn.sinjinsong.skeleton.service.article.ArticleServiceTest.findByBodyContainingWithHighlight(ArticleServiceTest.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
2017-07-15 18:10:23.174 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 5924 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:10:23.176 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:10:55.592 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 34.131 seconds (JVM running for 35.824)
2017-07-15 18:10:55.768 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:10:55.906 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 92] - searchHit.getHighlightFields().get("body"):null
2017-07-15 18:10:55.908 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 32] - Error happened in method: [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ]
2017-07-15 18:10:55.908 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 33] - Parameters: [Hybrid, 0, 5]
2017-07-15 18:10:55.911 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 34] - Exception StackTrace: {}
java.lang.NullPointerException: null
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$1.mapResults(ArticleServiceImpl.java:93)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.queryForPage(ElasticsearchTemplate.java:277)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(ArticleServiceImpl.java:82)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$FastClassBySpringCGLIB$$7ca1735a.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$EnhancerBySpringCGLIB$$f15a7217.findByBodyContainingWithHighlight(<generated>)
	at cn.sinjinsong.skeleton.service.article.ArticleServiceTest.findByBodyContainingWithHighlight(ArticleServiceTest.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
2017-07-15 18:12:09.460 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 9908 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:12:09.463 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:12:42.667 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 35.003 seconds (JVM running for 36.584)
2017-07-15 18:12:42.851 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:12:42.950 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 87] - searchHit:org.elasticsearch.search.internal.InternalSearchHit@6da3dcc3
2017-07-15 18:12:42.952 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 105] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 18:12:43.055 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 18:12:43.057 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 18:12:43.057 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:16:17.213 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 8884 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:16:17.214 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:16:50.415 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 34.354 seconds (JVM running for 35.957)
2017-07-15 18:16:50.557 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:16:50.640 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 86] - response.getHits().hits().length:1
2017-07-15 18:16:50.647 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 88] - searchHit:org.elasticsearch.search.internal.InternalSearchHit@4064fbdf
2017-07-15 18:16:50.650 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 106] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 18:16:50.753 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 18:16:50.754 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 18:16:50.754 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:26:42.603 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 6084 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:26:42.605 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:27:16.182 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 35.495 seconds (JVM running for 37.063)
2017-07-15 18:27:16.369 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:27:16.612 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 121] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 18:27:16.628 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 18:27:16.630 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 18:27:16.630 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:29:37.033 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 10936 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:29:37.036 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:30:17.754 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 42.921 seconds (JVM running for 44.926)
2017-07-15 18:30:17.991 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:30:18.213 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 104] - body:null
2017-07-15 18:30:18.223 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 122] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 18:30:18.244 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 18:30:18.246 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 18:30:18.248 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:33:08.443 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 6024 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:33:08.445 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:33:44.033 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 37.456 seconds (JVM running for 39.031)
2017-07-15 18:33:44.224 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:33:44.490 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 104] - body:null
2017-07-15 18:33:44.491 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 115] - afterReplacing:58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。
2017-07-15 18:33:44.498 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 123] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 18:33:44.510 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 18:33:44.511 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 18:33:44.511 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:34:59.738 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 10908 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:34:59.740 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:35:37.968 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 40.357 seconds (JVM running for 41.974)
2017-07-15 18:35:38.201 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:35:38.296 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 93] - searchHit:org.elasticsearch.search.internal.InternalSearchHit@114b8b04
2017-07-15 18:35:38.386 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 105] - body:null
2017-07-15 18:35:38.386 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 116] - afterReplacing:58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。
2017-07-15 18:35:38.393 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 124] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 18:35:38.436 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 18:35:38.438 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 18:35:38.439 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:36:48.088 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 9524 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:36:48.095 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:37:21.565 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 35.278 seconds (JVM running for 36.861)
2017-07-15 18:37:21.762 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:37:21.849 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 93] - searchHit:org.elasticsearch.search.internal.InternalSearchHit@d8714b4
2017-07-15 18:37:21.932 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 105] - body:null
2017-07-15 18:37:21.934 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 116] - afterReplacing:58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。
2017-07-15 18:37:21.940 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 124] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 18:37:21.940 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 18:37:21.941 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 18:37:21.941 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 18:38:53.281 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 9760 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:38:53.285 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:39:34.217 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 43.132 seconds (JVM running for 44.802)
2017-07-15 18:39:34.404 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:39:34.695 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 32] - Error happened in method: [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ]
2017-07-15 18:39:34.695 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 33] - Parameters: [Hybrid, 0, 5]
2017-07-15 18:39:34.700 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 34] - Exception StackTrace: {}
org.elasticsearch.action.search.SearchPhaseExecutionException: all shards failed
	at org.elasticsearch.action.search.AbstractSearchAsyncAction.onFirstPhaseResult(AbstractSearchAsyncAction.java:206)
	at org.elasticsearch.action.search.AbstractSearchAsyncAction$1.onFailure(AbstractSearchAsyncAction.java:152)
	at org.elasticsearch.action.ActionListenerResponseHandler.handleException(ActionListenerResponseHandler.java:46)
	at org.elasticsearch.transport.TransportService$DirectResponseChannel.processException(TransportService.java:874)
	at org.elasticsearch.transport.TransportService$DirectResponseChannel.sendResponse(TransportService.java:852)
	at org.elasticsearch.transport.TransportService$4.onFailure(TransportService.java:389)
	at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:39)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.elasticsearch.index.query.QueryParsingException: [match] analyzer [ik_smart] not found
	at org.elasticsearch.index.query.MatchQueryParser.parse(MatchQueryParser.java:101)
	at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:250)
	at org.elasticsearch.index.query.QueryParseContext.parseInnerFilter(QueryParseContext.java:263)
	at org.elasticsearch.index.query.functionscore.FunctionScoreQueryParser.parseFiltersAndFunctions(FunctionScoreQueryParser.java:219)
	at org.elasticsearch.index.query.functionscore.FunctionScoreQueryParser.parse(FunctionScoreQueryParser.java:129)
	at org.elasticsearch.index.query.QueryParseContext.parseInnerQuery(QueryParseContext.java:250)
	at org.elasticsearch.index.query.IndexQueryParserService.innerParse(IndexQueryParserService.java:324)
	at org.elasticsearch.index.query.IndexQueryParserService.parse(IndexQueryParserService.java:224)
	at org.elasticsearch.index.query.IndexQueryParserService.parse(IndexQueryParserService.java:219)
	at org.elasticsearch.search.query.QueryParseElement.parse(QueryParseElement.java:33)
	at org.elasticsearch.search.SearchService.parseSource(SearchService.java:856)
	at org.elasticsearch.search.SearchService.createContext(SearchService.java:667)
	at org.elasticsearch.search.SearchService.createAndPutContext(SearchService.java:633)
	at org.elasticsearch.search.SearchService.executeDfsPhase(SearchService.java:264)
	at org.elasticsearch.search.action.SearchServiceTransportAction$SearchDfsTransportHandler.messageReceived(SearchServiceTransportAction.java:360)
	at org.elasticsearch.search.action.SearchServiceTransportAction$SearchDfsTransportHandler.messageReceived(SearchServiceTransportAction.java:357)
	at org.elasticsearch.transport.TransportRequestHandler.messageReceived(TransportRequestHandler.java:33)
	at org.elasticsearch.transport.RequestHandlerRegistry.processMessageReceived(RequestHandlerRegistry.java:77)
	at org.elasticsearch.transport.TransportService$4.doRun(TransportService.java:378)
	at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37)
	... 3 common frames omitted
2017-07-15 18:53:53.661 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 6184 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:53:53.688 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:54:28.802 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 37.243 seconds (JVM running for 39.019)
2017-07-15 18:54:28.968 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:54:29.066 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 32] - Error happened in method: [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ]
2017-07-15 18:54:29.067 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 33] - Parameters: [Hybrid, 0, 5]
2017-07-15 18:54:29.071 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 34] - Exception StackTrace: {}
org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9300}]
	at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodesAreAvailable(TransportClientNodesService.java:326)
	at org.elasticsearch.client.transport.TransportClientNodesService.execute(TransportClientNodesService.java:223)
	at org.elasticsearch.client.transport.support.TransportProxyClient.execute(TransportProxyClient.java:55)
	at org.elasticsearch.client.transport.TransportClient.doExecute(TransportClient.java:295)
	at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:359)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:86)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:56)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.doSearch(ElasticsearchTemplate.java:900)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.queryForPage(ElasticsearchTemplate.java:276)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(ArticleServiceImpl.java:88)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$FastClassBySpringCGLIB$$7ca1735a.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$EnhancerBySpringCGLIB$$5d371bfe.findByBodyContainingWithHighlight(<generated>)
	at cn.sinjinsong.skeleton.service.article.ArticleServiceTest.findByBodyContainingWithHighlight(ArticleServiceTest.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
2017-07-15 18:57:16.141 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 7980 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:57:16.143 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 18:57:54.968 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 41.435 seconds (JVM running for 43.148)
2017-07-15 18:57:55.143 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 18:57:55.257 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 32] - Error happened in method: [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ]
2017-07-15 18:57:55.257 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 33] - Parameters: [Hybrid, 0, 5]
2017-07-15 18:57:55.260 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 34] - Exception StackTrace: {}
org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9300}]
	at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodesAreAvailable(TransportClientNodesService.java:326)
	at org.elasticsearch.client.transport.TransportClientNodesService.execute(TransportClientNodesService.java:223)
	at org.elasticsearch.client.transport.support.TransportProxyClient.execute(TransportProxyClient.java:55)
	at org.elasticsearch.client.transport.TransportClient.doExecute(TransportClient.java:295)
	at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:359)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:86)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:56)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.doSearch(ElasticsearchTemplate.java:900)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.queryForPage(ElasticsearchTemplate.java:276)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(ArticleServiceImpl.java:88)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$FastClassBySpringCGLIB$$7ca1735a.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$EnhancerBySpringCGLIB$$f4984d90.findByBodyContainingWithHighlight(<generated>)
	at cn.sinjinsong.skeleton.service.article.ArticleServiceTest.findByBodyContainingWithHighlight(ArticleServiceTest.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
2017-07-15 18:59:44.635 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 5952 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 18:59:44.637 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 19:00:20.802 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 37.917 seconds (JVM running for 39.557)
2017-07-15 19:00:21.056 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 19:00:21.162 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 32] - Error happened in method: [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ]
2017-07-15 19:00:21.163 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 33] - Parameters: [Hybrid, 0, 5]
2017-07-15 19:00:21.168 ERROR [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 34] - Exception StackTrace: {}
org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [{#transport#-1}{127.0.0.1}{127.0.0.1:9300}]
	at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodesAreAvailable(TransportClientNodesService.java:326)
	at org.elasticsearch.client.transport.TransportClientNodesService.execute(TransportClientNodesService.java:223)
	at org.elasticsearch.client.transport.support.TransportProxyClient.execute(TransportProxyClient.java:55)
	at org.elasticsearch.client.transport.TransportClient.doExecute(TransportClient.java:295)
	at org.elasticsearch.client.support.AbstractClient.execute(AbstractClient.java:359)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:86)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:56)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.doSearch(ElasticsearchTemplate.java:900)
	at org.springframework.data.elasticsearch.core.ElasticsearchTemplate.queryForPage(ElasticsearchTemplate.java:276)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(ArticleServiceImpl.java:88)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$FastClassBySpringCGLIB$$7ca1735a.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:52)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673)
	at cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl$$EnhancerBySpringCGLIB$$9cfe18ea.findByBodyContainingWithHighlight(<generated>)
	at cn.sinjinsong.skeleton.service.article.ArticleServiceTest.findByBodyContainingWithHighlight(ArticleServiceTest.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
2017-07-15 19:04:23.463 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 6696 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 19:04:23.466 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 19:05:02.301 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 41.289 seconds (JVM running for 43.639)
2017-07-15 19:05:02.526 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 19:05:02.796 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 93] - searchHit:org.elasticsearch.search.internal.InternalSearchHit@5e2df034
2017-07-15 19:05:02.868 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 105] - body:null
2017-07-15 19:05:02.869 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 116] - afterReplacing:58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。
2017-07-15 19:05:02.894 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 124] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase",
            "analyzer" : "ik_smart"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase",
            "analyzer" : "ik_smart"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 19:05:02.897 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 19:05:02.899 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 19:05:02.899 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 19:08:10.441 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 5968 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 19:08:10.443 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 19:08:48.259 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 39.97 seconds (JVM running for 41.805)
2017-07-15 19:08:48.537 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 19:08:48.653 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 93] - searchHit:org.elasticsearch.search.internal.InternalSearchHit@38cf78cb
2017-07-15 19:08:48.779 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 104] - fields:{}
2017-07-15 19:08:48.780 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 106] - body:null
2017-07-15 19:08:48.780 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 117] - afterReplacing:58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。
2017-07-15 19:08:48.797 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 125] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase",
            "analyzer" : "ik_smart"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase",
            "analyzer" : "ik_smart"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 19:08:48.797 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 19:08:48.802 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 19:08:48.803 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
2017-07-15 19:12:05.483 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 48] - Starting ArticleServiceTest on LAPTOP-0E5JL9PN with PID 4928 (started by songx in D:\idea\SpringBootSkeleton\skeleton)
2017-07-15 19:12:05.485 INFO  [main] c.s.s.s.article.ArticleServiceTest [SpringApplication.java : 597] - The following profiles are active: dev
2017-07-15 19:12:40.292 INFO  [main] c.s.s.s.article.ArticleServiceTest [StartupInfoLogger.java : 57] - Started ArticleServiceTest in 36.624 seconds (JVM running for 38.221)
2017-07-15 19:12:40.470 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 22] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] begins with Parameters: [Hybrid, 0, 5]
2017-07-15 19:12:40.551 INFO  [main] c.s.s.s.a.impl.ArticleServiceImpl [ArticleServiceImpl.java : 67] - DSL:{
  "function_score" : {
    "functions" : [ {
      "filter" : {
        "match" : {
          "title" : {
            "query" : "Hybrid",
            "type" : "phrase",
            "analyzer" : "ik_smart"
          }
        }
      },
      "weight" : 1000.0
    }, {
      "filter" : {
        "match" : {
          "body" : {
            "query" : "Hybrid",
            "type" : "phrase",
            "analyzer" : "ik_smart"
          }
        }
      },
      "weight" : 500.0
    } ],
    "score_mode" : "sum",
    "min_score" : 10.0
  }
}
2017-07-15 19:12:40.710 INFO  [main] c.s.skeleton.aop.LoggingAspect [LoggingAspect.java : 27] - The method [ Page cn.sinjinsong.skeleton.service.article.impl.ArticleServiceImpl.findByBodyContainingWithHighlight(String,Integer,Integer) ] ends with Result: Page 1 of 1 containing cn.sinjinsong.skeleton.domain.entity.article.ArticleDO instances
2017-07-15 19:12:40.711 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 70] - size:1
2017-07-15 19:12:40.711 INFO  [main] c.s.s.s.article.ArticleServiceTest [ArticleServiceTest.java : 72] - ArticleDO(id=2, author=杜艳新, title=58同城iOS客户端Hybrid框架探索, body=58同城iOS客户端的Hybrid框架在最初设计和演进的过程中，遇到了许多问题。为此，整个Hybrid框架产生了很大的变化。本文作者将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架提供一些参考。

引言
Hybrid App是指同时使用Native与Web的App。Native界面具有良好的用户体验，但是不易动态改变，且开发成本较高。对于变动较大的页面，使用Web来实现是一个比较好的选择，所以，目前很多主流App都采用Native与Web混合的方式搭建。58同城客户端上线不久即采用了Hybrid方式，至今已有六七年。而iOS客户端的Hybrid框架在最初设计和演进的过程中，随着时间推移和业务需求的不断增加，遇到了许多问题。为了解决它们，整个Hybrid框架产生了很大的变化。本文将遇到的典型问题进行了总结，并重点介绍58 iOS采用的解决方案，希望能给读者搭建自己的Hybrid框架一些参考。主要包括以下四个方面：

1. 通讯方式以及通讯框架
58 App最初采用的Web调用Native的通讯方式是AJAX请求，不仅存在内存泄露问题，且Native在回调给Web结果时无法确定回调给哪个Web View。另外，如何搭建一个简单、实用、扩展性好的Hybrid框架是一个重点内容。这些内容将在通讯部分详细介绍。

2. 缓存原理及缓存框架
提升Web页面响应速度的一个有效手段就是使用缓存。58 iOS客户端如何对Web资源进行缓存以及如何搭建Hybrid缓存框架将在缓存部分介绍。

3. 性能
iOS 8推出了WebKit框架，核心是WKWebView，其在性能上要远优于UIWebView，并且提供了一些新的功能，但遗憾的是WKWebView不支持自定义缓存。我们经过调研和测试发现了一些从UIWebView升级到WKWebView的可行解决方案，将在性能部分重点介绍。

4. 耦合
58 iOS客户端最初的Hybrid框架设计过于简单，导致Web载体页渐渐变得十分臃肿，继承关系十分复杂。耦合部分详细介绍了平稳解决载体页耦合问题的方案。

通讯
Hybrid框架首先要考虑的问题就是Web与Native之间的通讯。苹果在iOS 7系统推出了JavaScriptCore.framework框架，通过该框架可以方便地实现JavaScript与Native的通讯工作。但是在58 App最早引入Hybrid时，需要支持iOS 7以下的系统版本，所以58 App并没有使用JavaScriptCore.framework，而是采用了更原始的方式。

传统的通讯方式（如图1所示）中，Native调用JavaScript代码比较简单，直接使用UIWebView提供的接口stringByEvaluatingJavaScriptFromString:就可以实现。而JavaScript调用Native的功能需要通过拦截请求的方式来实现。即JavaScript发送一个特殊的URL请求，该请求并不是真正的网络访问请求，而是调用Native功能的请求，并传递相关的参数。Native端收到请求后进行判断，如果是功能调URL请求则调用Native的相应功能，而不进行网络访问。)
